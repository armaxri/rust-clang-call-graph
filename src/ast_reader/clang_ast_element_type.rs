use strum_macros::EnumString;

// Taken from https://github.com/dtolnay/clang-ast/blob/master/src/kind.rs
#[derive(Debug, PartialEq, EnumString)]
pub enum ClangAstElementType {
    AbiTagAttr,
    AccessSpecDecl,
    AliasAttr,
    AlignedAttr,
    AllocAlignAttr,
    AllocSizeAttr,
    AlwaysInlineAttr,
    ArrayInitIndexExpr,
    ArrayInitLoopExpr,
    ArraySubscriptExpr,
    ArrayTypeTraitExpr,
    AsmLabelAttr,
    AtomicExpr,
    AtomicType,
    AttributedStmt,
    AttributedType,
    AutoType,
    AvailabilityAttr,
    BinaryOperator,
    BindingDecl,
    BlockPointerType,
    BreakStmt,
    BuiltinAttr,
    BuiltinBitCastExpr,
    BuiltinTemplateDecl,
    BuiltinType,
    CStyleCastExpr,
    CXX11NoReturnAttr,
    CXXBindTemporaryExpr,
    CXXBoolLiteralExpr,
    CXXCatchStmt,
    CXXConstCastExpr,
    CXXConstructExpr,
    CXXConstructorDecl,
    CXXConversionDecl,
    CXXCtorInitializer,
    CXXDeductionGuideDecl,
    CXXDefaultArgExpr,
    CXXDefaultInitExpr,
    CXXDeleteExpr,
    CXXDependentScopeMemberExpr,
    CXXDestructorDecl,
    CXXDynamicCastExpr,
    CXXFoldExpr,
    CXXForRangeStmt,
    CXXFunctionalCastExpr,
    CXXInheritedCtorInitExpr,
    CXXMemberCallExpr,
    CXXMethodDecl,
    CXXNewExpr,
    CXXNoexceptExpr,
    CXXNullPtrLiteralExpr,
    CXXOperatorCallExpr,
    CXXPseudoDestructorExpr,
    CXXRecordDecl,
    CXXReinterpretCastExpr,
    CXXRewrittenBinaryOperator,
    CXXScalarValueInitExpr,
    CXXStaticCastExpr,
    CXXTemporaryObjectExpr,
    CXXThisExpr,
    CXXThrowExpr,
    CXXTryStmt,
    CXXTypeidExpr,
    CXXUnresolvedConstructExpr,
    CallExpr,
    CallbackAttr,
    CaseStmt,
    CharacterLiteral,
    ClassTemplateDecl,
    ClassTemplatePartialSpecializationDecl,
    ClassTemplateSpecializationDecl,
    ColdAttr,
    ComplexType,
    CompoundAssignOperator,
    CompoundRequirement,
    CompoundStmt,
    ConceptDecl,
    ConceptSpecializationExpr,
    ConditionalOperator,
    ConstAttr,
    ConstantArrayType,
    ConstantExpr,
    ConstructorUsingShadowDecl,
    ContinueStmt,
    DLLImportAttr,
    DecayedType,
    DeclRefExpr,
    DeclStmt,
    DecltypeType,
    DecompositionDecl,
    DefaultStmt,
    DependentNameType,
    DependentScopeDeclRefExpr,
    DependentSizedArrayType,
    DependentTemplateSpecializationType,
    DeprecatedAttr,
    DiagnoseIfAttr,
    DisableTailCallsAttr,
    DoStmt,
    ElaboratedType,
    EmptyDecl,
    EnableIfAttr,
    EnumConstantDecl,
    EnumDecl,
    EnumType,
    ExprWithCleanups,
    FallThroughAttr,
    FieldDecl,
    FinalAttr,
    FloatingLiteral,
    ForStmt,
    FormatArgAttr,
    FormatAttr,
    FriendDecl,
    FullComment,
    FunctionDecl,
    FunctionProtoType,
    FunctionTemplateDecl,
    GCCAsmStmt,
    GNUInlineAttr,
    GNUNullExpr,
    GotoStmt,
    IfStmt,
    ImplicitCastExpr,
    ImplicitValueInitExpr,
    IncompleteArrayType,
    IndirectFieldDecl,
    InitListExpr,
    InjectedClassNameType,
    IntegerLiteral,
    InternalLinkageAttr,
    LValueReferenceType,
    LabelStmt,
    LambdaExpr,
    LikelyAttr,
    LinkageSpecDecl,
    MaterializeTemporaryExpr,
    MaxFieldAlignmentAttr,
    MayAliasAttr,
    MemberExpr,
    MemberPointerType,
    ModeAttr,
    NamespaceAliasDecl,
    NamespaceDecl,
    NestedRequirement,
    NoAliasAttr,
    NoDebugAttr,
    NoEscapeAttr,
    NoInlineAttr,
    NoSanitizeAttr,
    NoThrowAttr,
    NoUniqueAddressAttr,
    NonNullAttr,
    NonTypeTemplateParmDecl,
    NullStmt,
    OffsetOfExpr,
    OpaqueValueExpr,
    OverrideAttr,
    OwnerAttr,
    PackExpansionExpr,
    PackExpansionType,
    PackedAttr,
    ParagraphComment,
    ParenExpr,
    ParenListExpr,
    ParenType,
    ParmVarDecl,
    PointerAttr,
    PointerType,
    PredefinedExpr,
    PreferredNameAttr,
    PureAttr,
    QualType,
    RValueReferenceType,
    RecordDecl,
    RecordType,
    RecoveryExpr,
    RequiresExpr,
    RestrictAttr,
    ReturnStmt,
    ReturnsNonNullAttr,
    ReturnsTwiceAttr,
    SimpleRequirement,
    SizeOfPackExpr,
    StaticAssertDecl,
    StringLiteral,
    SubstNonTypeTemplateParmExpr,
    SubstTemplateTypeParmType,
    SwiftAttrAttr,
    SwitchStmt,
    TemplateArgument,
    TemplateSpecializationType,
    TemplateTemplateParmDecl,
    TemplateTypeParmDecl,
    TemplateTypeParmType,
    TextComment,
    TranslationUnitDecl,
    TypeAliasDecl,
    TypeAliasTemplateDecl,
    TypeOfExprType,
    TypeRequirement,
    TypeTraitExpr,
    TypeVisibilityAttr,
    TypedefDecl,
    TypedefType,
    UnaryExprOrTypeTraitExpr,
    UnaryOperator,
    UnaryTransformType,
    UnavailableAttr,
    UnlikelyAttr,
    UnresolvedLookupExpr,
    UnresolvedMemberExpr,
    UnresolvedUsingIfExistsDecl,
    UnresolvedUsingTypenameDecl,
    UnresolvedUsingValueDecl,
    UnusedAttr,
    UserDefinedLiteral,
    UsingDecl,
    UsingDirectiveDecl,
    UsingEnumDecl,
    UsingIfExistsAttr,
    UsingShadowDecl,
    UsingType,
    VTablePointerAuthenticationAttr,
    VarDecl,
    VarTemplateDecl,
    VarTemplatePartialSpecializationDecl,
    VarTemplateSpecializationDecl,
    VisibilityAttr,
    WarnUnusedResultAttr,
    WeakImportAttr,
    WeakRefAttr,
    WhileStmt,
}

impl ClangAstElementType {
    pub fn from_str(type_str: &str) -> Self {
        match type_str.parse::<ClangAstElementType>() {
            Ok(enum_val) => enum_val,
            Err(_) => panic!(
                "Invalid ClangAstElementType '{}', contact the developer.",
                type_str
            ),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_clang_ast_element_type_from_str() {
        assert_eq!(
            ClangAstElementType::from_str("AbiTagAttr"),
            ClangAstElementType::AbiTagAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("AccessSpecDecl"),
            ClangAstElementType::AccessSpecDecl
        );
        assert_eq!(
            ClangAstElementType::from_str("AliasAttr"),
            ClangAstElementType::AliasAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("AlignedAttr"),
            ClangAstElementType::AlignedAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("AllocAlignAttr"),
            ClangAstElementType::AllocAlignAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("AllocSizeAttr"),
            ClangAstElementType::AllocSizeAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("AlwaysInlineAttr"),
            ClangAstElementType::AlwaysInlineAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("ArrayInitIndexExpr"),
            ClangAstElementType::ArrayInitIndexExpr
        );
        assert_eq!(
            ClangAstElementType::from_str("ArrayInitLoopExpr"),
            ClangAstElementType::ArrayInitLoopExpr
        );
        assert_eq!(
            ClangAstElementType::from_str("ArraySubscriptExpr"),
            ClangAstElementType::ArraySubscriptExpr
        );
        assert_eq!(
            ClangAstElementType::from_str("ArrayTypeTraitExpr"),
            ClangAstElementType::ArrayTypeTraitExpr
        );
        assert_eq!(
            ClangAstElementType::from_str("AsmLabelAttr"),
            ClangAstElementType::AsmLabelAttr
        );
        assert_eq!(
            ClangAstElementType::from_str("AtomicExpr"),
            ClangAstElementType::AtomicExpr
        );
        assert_eq!(
            ClangAstElementType::from_str("AtomicType"),
            ClangAstElementType::AtomicType
        );
        assert_eq!(
            ClangAstElementType::from_str("AttributedStmt"),
            ClangAstElementType::AttributedStmt
        );
        assert_eq!(
            ClangAstElementType::from_str("AttributedType"),
            ClangAstElementType::AttributedType
        );
        assert_eq!(
            ClangAstElementType::from_str("AutoType"),
            ClangAstElementType::AutoType
        );
        assert_eq!(
            ClangAstElementType::from_str("AvailabilityAttr"),
            ClangAstElementType::AvailabilityAttr
        );
    }

    #[test]
    #[should_panic(expected = "Invalid ClangAstElementType 'InvalidType', contact the developer.")]
    fn test_invalid_clang_ast_element_type_from_str() {
        let invalid_type = "InvalidType";
        ClangAstElementType::from_str(invalid_type);
    }
}
